<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Glass WebGL Demo (Direct Mouse Follow)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; display: flex; justify-content: center; align-items: center; min-height: 100vh; cursor: default; }
        canvas { display: block; background-color: #000; border: 1px solid #333; }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #eee;
            font-family: sans-serif;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="info">
        Liquid Glass WebGL Demo<br>
        (SDF + Ray Marching + Refraction + Background Image + Direct Mouse Follow)
    </div>

    <script>
        // --- WebGL Setup ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('Your browser does not support WebGL. Please try a different browser.');
        }

        // Mouse position tracking
        let mouseX = 0;
        let mouseY = 0;
        canvas.addEventListener('mousemove', (event) => {
            mouseX = event.clientX; // Raw X coordinate
            mouseY = event.clientY; // Raw Y coordinate
        });

        // Set canvas resolution to fill the window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial resize

        // Vertex Shader (simple pass-through for full screen quad)
        const vsSource = `
            attribute vec4 a_position;
            void main() {
                gl_Position = a_position;
            }
        `;

        // Fragment Shader (core logic for Liquid Glass)
        const fsSource = `
            precision highp float;

            uniform vec2  iResolution;
            uniform float iTime;
            uniform sampler2D iChannel0; // Background image
            uniform vec2  iMouse;    // Mouse X/Y coordinates from JS

            // --- Utility Functions ---

            // Hash function for random-like values
            vec2 hash22(vec2 p) {
                p = fract(p * vec2(5.3983, 5.4427));
                p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));
                return fract(vec2(p.x * p.y, p.x + p.y));
            }

            // --- SDF Functions ---

            // Round Box SDF (main glass shape)
            float sdRoundBox(vec3 p, vec3 b, float r) {
                vec3 q = abs(p) - b;
                return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
            }

            // --- Scene SDF (defines the glass object) ---
            float map(vec3 p) {
                // Adjust point 'p' based on mouse position to move the object
                // Normalize mouse coords to -1 to 1 range
                vec2 mouseNorm = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;
                
                // Scale mouse movement for object displacement
                // Y-axis needs to be inverted for traditional screen coords (positive up in GLSL, positive down in screen)
                vec3 mouseOffset = vec3(mouseNorm.x * 0.7, -mouseNorm.y * 0.7, 0.0); // Adjust 0.7 for movement sensitivity

                p -= mouseOffset; // Subtract offset from 'p' to move the object

                vec3 glassSize = vec3(0.6, 0.3, 0.06); // Width, Height, Thickness
                float cornerRadius = 0.08;

                // Add simple animation to the glass thickness to simulate 'liquid' flow
                float thicknessDeform = sin(p.x * 5.0 + iTime * 2.0) * 0.02 +
                                        cos(p.y * 5.0 + iTime * 1.5) * 0.02;
                glassSize.z += thicknessDeform;
                glassSize.z = max(0.01, glassSize.z); // Ensure thickness is not too small

                return sdRoundBox(p, glassSize, cornerRadius);
            }

            // --- Ray Marching ---
            // Define constants for ray marching parameters directly in GLSL
            const float MAX_RAY_DIST = 10.0;
            const float HIT_EPSILON = 0.001;
            const int MAX_STEPS = 80;

            vec3 rayMarch(vec3 ro, vec3 rd) { // Parameters removed from signature
                float dist = 0.0;
                for (int i = 0; i < MAX_STEPS; i++) { // Loop condition uses constant
                    vec3 p = ro + rd * dist;
                    float d = map(p);
                    if (d < HIT_EPSILON) { // Comparison uses constant
                        return p; // Return intersection point
                    }
                    dist += d;
                    if (dist > MAX_RAY_DIST) { // Comparison uses constant
                        break;
                    }
                }
                return ro + rd * MAX_RAY_DIST; // No hit, return point at max distance
            }

            // Calculate surface normal using finite differences
            vec3 calculateNormal(vec3 p) {
                vec2 eps = vec2(0.001, 0.0);
                return normalize(vec3(
                    map(p + eps.xyy) - map(p - eps.xyy),
                    map(p + eps.yxy) - map(p - eps.yxy),
                    map(p + eps.yyx) - map(p - eps.yyx)
                ));
            }

            // --- Refraction Function (Snell's Law) ---
            vec3 refractRay(vec3 I, vec3 N, float eta) {
                float N_dot_I = dot(N, I);
                float k = 1.0 - eta * eta * (1.0 - N_dot_I * N_dot_I);
                if (k < 0.0) return vec3(0.0); // Total internal reflection or invalid
                return eta * I - (eta * N_dot_I + sqrt(k)) * N;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / iResolution.xy; // Normalized screen coordinates (0 to 1)
                vec2 p_ndc = -1.0 + 2.0 * uv; // Normalized Device Coordinates (-1 to 1)

                // Camera setup (fixed position now, object moves relative to it)
                vec3 ro = vec3(0.0, 0.0, 2.5); 

                // Adjust ray direction for aspect ratio
                float aspectRatio = iResolution.x / iResolution.y;
                vec3 rd = normalize(vec3(p_ndc.x * aspectRatio, p_ndc.y, -1.5)); // Ray Direction towards scene

                float glassIOR = 1.5; // Index of Refraction for typical glass (adjust for ice/jelly)

                // 1. Ray march to find the first intersection with the glass surface
                vec3 glassIntersectionPoint = rayMarch(ro, rd);
                float distToGlass = length(glassIntersectionPoint - ro);

                vec4 finalColor = vec4(0.0); // Initialize with alpha 0.0

                // If we hit the glass (check if distance is less than maxDist)
                if (distToGlass < MAX_RAY_DIST - HIT_EPSILON * 2.0) {
                    vec3 glassNormal = calculateNormal(glassIntersectionPoint);

                    // Ensure normal points outwards from the surface for refraction
                    if (dot(rd, glassNormal) > 0.0) {
                        glassNormal = -glassNormal;
                    }

                    // 2. Refract the ray *into* the glass (Air to Glass)
                    vec3 refractedDirIntoGlass = refractRay(rd, glassNormal, 1.0 / glassIOR);

                    // To avoid self-intersection issues, start the internal ray march slightly inside the object
                    vec3 startInsidePoint = glassIntersectionPoint + refractedDirIntoGlass * HIT_EPSILON * 2.0;

                    // 3. Ray march *inside* the glass to find the exit point
                    vec3 exitPoint = rayMarch(startInsidePoint, refractedDirIntoGlass);

                    // 4. Calculate normal at exit point
                    vec3 exitNormal = calculateNormal(exitPoint);
                    // Ensure exit normal points outwards from glass
                    if (dot(refractedDirIntoGlass, exitNormal) > 0.0) {
                        exitNormal = -exitNormal;
                    }

                    // 5. Refract the ray *out of* the glass (Glass to Air)
                    vec3 finalRefractedDir = refractRay(refractedDirIntoGlass, -exitNormal, glassIOR / 1.0);

                    // 6. Sample background/environment texture using the final refracted ray direction
                    vec2 refractedUV = uv + finalRefractedDir.xy * 0.2 * (1.0 - abs(p_ndc.x));
                    refractedUV = clamp(refractedUV, 0.0, 1.0);

                    // Use the background image texture
                    vec3 refractedColor = texture2D(iChannel0, refractedUV).rgb;

                    // Add some basic Fresnel reflection at the entry point
                    float fresnelFactor = pow(1.0 - max(0.0, dot(-rd, glassNormal)), 3.0);
                    vec3 reflectedColor = texture2D(iChannel0, uv).rgb;

                    // Mix refracted and reflected colors based on Fresnel factor
                    finalColor.rgb = mix(refractedColor, reflectedColor, fresnelFactor);

                    // Add some subtle edge lighting/tint to the glass itself
                    float rimLight = pow(1.0 - max(0.0, dot(glassNormal, -rd)), 5.0);
                    finalColor.rgb += vec3(0.2, 0.4, 0.6) * rimLight * 0.5;

                    // Apply a slight internal tint to the glass
                    finalColor.rgb *= 0.95;
                    finalColor.a = 1.0;
                } else {
                    // If no glass is hit, just sample the background directly
                    finalColor.rgb = texture2D(iChannel0, uv).rgb;
                    finalColor.a = 1.0;
                }

                gl_FragColor = finalColor;
            }
        `;

        // --- WebGL Helper Functions ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

            if (!vertexShader || !fragmentShader) {
                return null;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Error linking program:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const shaderProgram = createProgram(gl, vsSource, fsSource);

        if (!shaderProgram) {
            console.error("Failed to create WebGL program. Check console for shader compilation/linking errors.");
            document.getElementById('info').textContent = 'Error: WebGL initialization failed. Check browser console.';
            throw new Error("WebGL program creation failed.");
        }

        gl.useProgram(shaderProgram);

        // --- Set up full-screen quad ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1.0, -1.0, // bottom-left
             1.0, -1.0, // bottom-right
            -1.0,  1.0, // top-left
            -1.0,  1.0, // top-left
             1.0, -1.0, // bottom-right
             1.0,  1.0, // top-right
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // --- Get Uniform Locations ---
        const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'iResolution');
        const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'iTime');
        const backgroundTextureUniformLocation = gl.getUniformLocation(shaderProgram, 'iChannel0');
        const mouseUniformLocation = gl.getUniformLocation(shaderProgram, 'iMouse');

        let startTime = Date.now();

        // --- Load background image ---
        const backgroundImage = new Image();
        backgroundImage.src = 'back.jpg'; // Replace with your image URL
        let backgroundTexture;

        backgroundImage.onload = () => {
            backgroundTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, backgroundImage);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            requestAnimationFrame(render);
        };

        if(backgroundImage.complete && backgroundImage.naturalWidth > 0) {
            backgroundImage.onload();
        } else {
            backgroundImage.onerror = () => {
                console.error("Failed to load background image. Please check the URL or use a local image.");
                document.getElementById('info').textContent = 'Error: Failed to load background image. Using default background.';
                requestAnimationFrame(render);
            };
        }

        // --- Render Loop ---
        function render() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(timeUniformLocation, (Date.now() - startTime) * 0.001);

            gl.uniform2f(mouseUniformLocation, mouseX, mouseY);

            if (backgroundTexture) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);
                gl.uniform1i(backgroundTextureUniformLocation, 0);
            }

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }
    </script>
</body>
</html>